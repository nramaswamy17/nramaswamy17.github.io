<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MPC Visualization with Lane Changing</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2a2a2a;
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
            margin: 10px 0;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .main-view {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .controls-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e0e0e0;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #4CAF50;
        }
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        button:disabled {
            background: linear-gradient(45deg, #666, #555);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button.danger {
            background: linear-gradient(45deg, #f44336, #da190b);
        }
        button.lane-left {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        button.lane-right {
            background: linear-gradient(45deg, #FF9800, #F57C00);
        }
        canvas {
            border-radius: 10px;
            background: #000;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .metric-card {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        .performance-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }
        .performance-indicator.good { background: #4CAF50; }
        .performance-indicator.warning { background: #FF9800; }
        .performance-indicator.error { background: #f44336; }
        .lane-controls {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }
        .lane-controls h3 {
            margin-top: 0;
            color: #2196F3;
            text-align: center;
        }
        .lane-status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>MPC Lane Change Assist</h1>
            <p>Model Predictive Control for Autonomous Vehicle with Lane Change Assistance</p>
        </div>

        <div class="dashboard">
            <div class="main-view">
                <canvas id="simulationCanvas" width="900" height="600"></canvas>
            </div>

            <div class="controls-panel">
                <div>
                    <h3>Lane Control</h3>
                    <div class="lane-controls">
                        <div class="lane-status" id="laneStatus">Current Lane: Right</div>
                        <button id="leftLaneBtn" class="lane-left">üèÉ Change to Left Lane</button>
                        <button id="rightLaneBtn" class="lane-right">üèÉ Change to Right Lane</button>
                    </div>
                </div>

                <div>
                    <h3>Simulation Control</h3>
                    <button id="pauseResumeBtn">Pause</button>
                    <button id="resetBtn" class="danger">Reset</button>
                </div>
            </div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-value" id="lateralError">0.00</div>
                <div class="metric-label">Lateral Error (m)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="headingError">0.0</div>
                <div class="metric-label">Heading Error (¬∞)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="steeringAngle">0.0</div>
                <div class="metric-label">Steering Command (¬∞)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="solveTime">2.3</div>
                <div class="metric-label">Solve Time (ms)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="controlFreq">10.0</div>
                <div class="metric-label">Control Frequency (Hz)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="laneChangeProgress">0</div>
                <div class="metric-label">Lane Change Progress (%)</div>
            </div>
        </div>
    </div>

    <script>
        class ProfessionalMPCVisualizer {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Vehicle dynamics parameters
                this.L = 2.7; // wheelbase
                this.dt = 0.1;
                this.laneWidth = 3.5;
                
                // MPC parameters
                this.horizon = 30;
                this.Q_lateral = 50.0;
                this.Q_heading = 10.0;
                this.R_steering = 1.0;
                
                // Lane changing parameters
                this.currentLane = 'right'; // 'left' or 'right'
                this.targetLane = 'right';
                this.isChangingLanes = false;
                this.laneChangeProgress = 0; // 0 to 1
                this.laneChangeSpeed = 0.25; // How fast to change lanes (per second) - MUCH SLOWER
                this.laneChangeDuration = 8.0; // Total time for lane change in seconds
                this.maxLaneChangeAngle = 3.0; // Maximum heading angle during lane changes (degrees)
                
                // Simulation state - Start in right lane
                this.vehicle = {
                    x: 50,
                    y: this.canvas.height / 2 + 20, // Start in right lane
                    theta: 0,
                    v: 30
                };
                
                this.targetSpeed = 30;
                this.currentSteering = 0;
                this.running = true;
                this.disturbanceLevel = 0;
                
                // Road animation parameters
                this.roadOffset = 0;
                this.roadSpeed = 0;
                
                // Visualization data
                this.trajectory = [];
                this.predictedPath = [];
                this.performanceHistory = [];
                
                // Performance metrics
                this.metrics = {
                    lateralError: 0,
                    headingError: 0,
                    steeringAngle: 0,
                    solveTime: 0,
                    trajectoryQuality: 100
                };
                
                this.initializeControls();
                this.generateLaneReference();
                this.animationLoop();
            }

            initializeControls() {
                // Control buttons
                document.getElementById('pauseResumeBtn').addEventListener('click', () => this.togglePauseResume());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                
                // Lane change buttons
                document.getElementById('leftLaneBtn').addEventListener('click', () => this.requestLaneChange('left'));
                document.getElementById('rightLaneBtn').addEventListener('click', () => this.requestLaneChange('right'));
            }

            updateParameter(param, value) {
                switch(param) {
                    case 'horizon': this.horizon = value; break;
                    case 'lateralWeight': this.Q_lateral = value; break;
                    case 'headingWeight': this.Q_heading = value; break;
                    case 'controlWeight': this.R_steering = value; break;
                    case 'speed': this.targetSpeed = value; this.vehicle.v = value; break;
                    case 'laneChangeDuration': this.laneChangeDuration = value; break;
                    case 'maxLaneChangeAngle': this.maxLaneChangeAngle = value; break;
                    case 'disturbance': this.disturbanceLevel = value; break;
                }
            }

            generateLaneReference() {
                // STRAIGHT ROAD - No curves!
                this.roadCenterLine = (x) => {
                    return this.canvas.height / 2; // Constant horizontal line
                };
                
                // Define road geometry
                this.laneWidth = 40; // Width of each lane
                this.totalRoadWidth = this.laneWidth * 2; // Total width for both lanes
                
                // Lane centers (straight lines)
                this.leftLaneCenter = (x) => this.roadCenterLine(x) - this.laneWidth/2;
                this.rightLaneCenter = (x) => this.roadCenterLine(x) + this.laneWidth/2;
                
                // Road edges (straight lines)
                this.leftRoadEdge = (x) => this.roadCenterLine(x) - this.totalRoadWidth/2;
                this.rightRoadEdge = (x) => this.roadCenterLine(x) + this.totalRoadWidth/2;
            }

            requestLaneChange(targetLane) {
                // Prevent lane change if already changing or already in target lane
                if (this.isChangingLanes || this.currentLane === targetLane) {
                    return;
                }
                
                this.targetLane = targetLane;
                this.isChangingLanes = true;
                this.laneChangeProgress = 0;
                
                // Update UI
                this.updateLaneChangeUI();
                
                console.log(`Lane change requested: ${this.currentLane} -> ${targetLane}`);
            }

            updateLaneChangeUI() {
                const leftBtn = document.getElementById('leftLaneBtn');
                const rightBtn = document.getElementById('rightLaneBtn');
                const laneStatus = document.getElementById('laneStatus');
                
                if (this.isChangingLanes) {
                    laneStatus.textContent = `Changing: ${this.currentLane.toUpperCase()} ‚Üí ${this.targetLane.toUpperCase()} (${Math.round(this.laneChangeProgress * 100)}%)`;
                    laneStatus.style.color = '#FF9800'; // Orange during change
                    
                    // Disable buttons during lane change
                    leftBtn.disabled = true;
                    rightBtn.disabled = true;
                } else {
                    laneStatus.textContent = `Current Lane: ${this.currentLane.toUpperCase()}`;
                    laneStatus.style.color = '#4CAF50'; // Green when stable
                    
                    // Enable/disable buttons based on current lane
                    leftBtn.disabled = (this.currentLane === 'left');
                    rightBtn.disabled = (this.currentLane === 'right');
                }
            }

            updateLaneChangeProgress() {
                if (!this.isChangingLanes) return;
                
                // Update progress based on fixed duration (smoother than speed-based)
                this.laneChangeProgress += this.dt / this.laneChangeDuration;
                
                // Complete lane change
                if (this.laneChangeProgress >= 1.0) {
                    this.laneChangeProgress = 1.0;
                    this.currentLane = this.targetLane;
                    this.isChangingLanes = false;
                    
                    console.log(`Lane change completed to: ${this.currentLane}`);
                }
                
                this.updateLaneChangeUI();
            }

            getCurrentTargetY(x) {
                // Calculate the target Y position based on current lane change status
                const leftY = this.leftLaneCenter(x);
                const rightY = this.rightLaneCenter(x);
                
                if (!this.isChangingLanes) {
                    // Not changing lanes, use current lane center
                    return this.currentLane === 'left' ? leftY : rightY;
                } else {
                    // Interpolate between current and target lane during lane change
                    const currentY = this.currentLane === 'left' ? leftY : rightY;
                    const targetY = this.targetLane === 'left' ? leftY : rightY;
                    
                    // MUCH SMOOTHER INTERPOLATION using cosine-based curve
                    const t = this.laneChangeProgress;
                    
                    // Method 1: Cosine interpolation (very smooth S-curve)
                    const cosineProgress = (1 - Math.cos(t * Math.PI)) / 2;
                    
                    // Method 2: Double smoothstep for extra smoothness
                    const smoothStep1 = t * t * (3.0 - 2.0 * t);
                    const doubleSmooth = smoothStep1 * smoothStep1 * (3.0 - 2.0 * smoothStep1);
                    
                    // Use cosine interpolation for the smoothest result
                    return currentY + (targetY - currentY) * cosineProgress;
                }
            }

            // Professional MPC implementation
            solveMPC() {
                const startTime = performance.now();
                
                let bestSteering = 0;
                let minCost = Infinity;
                let bestPrediction = [];
                
                // Grid search over steering commands
                const candidates = 501;
                const maxSteering = 0.5; // ~30 degrees
                
                for (let i = 0; i < candidates; i++) {
                    const steering = -maxSteering + (2 * maxSteering * i) / (candidates - 1);
                    const [cost, prediction] = this.evaluateTrajectory(steering);
                    
                    if (cost < minCost) {
                        minCost = cost;
                        bestSteering = steering;
                        bestPrediction = prediction;
                    }
                }
                
                this.predictedPath = bestPrediction;
                this.metrics.solveTime = performance.now() - startTime;
                
                return bestSteering;
            }

            evaluateTrajectory(steeringInput) {
                let state = { ...this.vehicle };
                let totalCost = 0;
                let prediction = [{ ...state }];
                
                for (let k = 0; k < this.horizon; k++) {
                    // Apply steering with gradual decay over horizon
                    const steering = steeringInput * Math.exp(-k * 0.05);
                    state = this.propagateDynamics(state, steering);
                    prediction.push({ ...state });
                    
                    // Get target lane center (accounts for lane changes)
                    const targetY = this.getCurrentTargetY(state.x);
                    const lateralError = state.y - targetY;
                    
                    // ADAPTIVE HEADING CONTROL - key improvement!
                    let desiredHeading = 0; // Normally want to point straight ahead
                    let adaptiveHeadingWeight = this.Q_heading;
                    
                    if (this.isChangingLanes) {
                        // During lane changes: allow slight angling but not too much
                        const laneChangeDirection = this.targetLane === 'left' ? -1 : 1;
                        const maxLaneChangeAngleRad = this.maxLaneChangeAngle * Math.PI / 180; // Convert degrees to radians
                        
                        // Scale desired angle based on lateral error - smaller as we approach target
                        const lateralErrorMagnitude = Math.abs(lateralError);
                        const angleScale = Math.min(1.0, lateralErrorMagnitude / 15.0); // Reduce angle as we get closer
                        desiredHeading = laneChangeDirection * maxLaneChangeAngleRad * angleScale;
                        
                        // SIGNIFICANTLY increase heading weight during lane changes to prevent excessive turning
                        adaptiveHeadingWeight = this.Q_heading * 8.0; // 8x stronger heading control for straighter motion
                    }
                    
                    const headingError = state.theta - desiredHeading;
                    const velocityError = state.v - this.targetSpeed;
                    
                    // Cost function with adaptive heading control
                    const timeWeight = 1 + k * 0.1;
                    totalCost += timeWeight * this.Q_lateral * lateralError * lateralError;
                    totalCost += timeWeight * adaptiveHeadingWeight * headingError * headingError;
                    totalCost += this.R_steering * steering * steering;
                    totalCost += 0.1 * velocityError * velocityError;
                    
                    // Add steering rate cost for smooth control
                    if (k > 0) {
                        const prevSteering = steeringInput * Math.exp(-(k-1) * 0.05);
                        const steeringRate = steering - prevSteering;
                        totalCost += 2.0 * steeringRate * steeringRate;
                    }
                    
                    // Extra penalty for excessive heading during lane changes
                    if (this.isChangingLanes) {
                        const maxAllowedHeading = this.maxLaneChangeAngle * Math.PI / 180 * 1.5; // 1.5x the target angle
                        if (Math.abs(state.theta) > maxAllowedHeading) {
                            totalCost += 200.0 * (Math.abs(state.theta) - maxAllowedHeading) * (Math.abs(state.theta) - maxAllowedHeading);
                        }
                    }
                }
                
                return [totalCost, prediction];
            }

            propagateDynamics(state, steering) {
                // Bicycle model implementation
                const beta = Math.atan(0.5 * Math.tan(steering));
                
                return {
                    x: state.x + this.dt * state.v * Math.cos(state.theta + beta),
                    y: state.y + this.dt * state.v * Math.sin(state.theta + beta),
                    theta: state.theta + this.dt * (state.v / this.L) * Math.sin(beta),
                    v: state.v // Constant velocity for lane keeping
                };
            }

            addDisturbance() {
                if (this.disturbanceLevel > 0) {
                    const noise = () => (Math.random() - 0.5) * this.disturbanceLevel * 0.01;
                    this.vehicle.y += noise() * 5;
                    this.vehicle.theta += noise() * 0.5;
                }
            }

            update() {
                if (!this.running) return;
                
                // Update lane change progress
                this.updateLaneChangeProgress();
                
                this.addDisturbance();
                
                // Solve MPC and apply control
                this.currentSteering = this.solveMPC();
                this.vehicle = this.propagateDynamics(this.vehicle, this.currentSteering);
                
                // Update road animation
                this.roadSpeed = this.vehicle.v * 0.5;
                this.roadOffset += this.roadSpeed * this.dt;
                if (this.roadOffset > 40) this.roadOffset = 0;
                
                // Update trajectory history
                this.trajectory.push({ x: this.vehicle.x, y: this.vehicle.y });
                if (this.trajectory.length > 300) this.trajectory.shift();
                
                // Wrap around canvas
                if (this.vehicle.x > this.canvas.width + 100) {
                    this.vehicle.x = -100;
                    this.trajectory = [];
                }
                
                // Update metrics
                this.updateMetrics();
            }

            updateMetrics() {
                const targetY = this.getCurrentTargetY(this.vehicle.x);
                this.metrics.lateralError = this.vehicle.y - targetY;
                this.metrics.headingError = this.vehicle.theta * 180 / Math.PI;
                this.metrics.steeringAngle = this.currentSteering * 180 / Math.PI;
                
                // Calculate trajectory quality
                const errorMagnitude = Math.abs(this.metrics.lateralError);
                this.metrics.trajectoryQuality = Math.max(0, 100 - errorMagnitude * 20);
                
                // Update UI
                document.getElementById('lateralError').textContent = this.metrics.lateralError.toFixed(2);
                document.getElementById('headingError').textContent = this.metrics.headingError.toFixed(1);
                document.getElementById('steeringAngle').textContent = this.metrics.steeringAngle.toFixed(1);
                document.getElementById('solveTime').textContent = this.metrics.solveTime.toFixed(1);
                document.getElementById('controlFreq').textContent = (1000 / Math.max(this.metrics.solveTime, 16)).toFixed(1);
                document.getElementById('laneChangeProgress').textContent = Math.round(this.laneChangeProgress * 100);
            }

            draw() {
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw straight road
                this.drawStraightRoad();
                
                // Draw vehicle trajectory
                this.drawTrajectory();
                
                // Draw MPC predicted trajectory
                this.drawPredictedPath();
                
                // Draw vehicle
                this.drawVehicle();
                
                // Draw performance overlay
                this.drawPerformanceOverlay();
                
                // Draw MPC status
                this.drawMPCStatus();
                
                // Draw legend
                this.drawLegend();
            }

            drawStraightRoad() {
                // Calculate road positions relative to vehicle (this is the key fix!)
                const worldRoadCenterY = this.canvas.height / 2; // Road center in world coordinates
                const roadCenterY = worldRoadCenterY - this.vehicle.y + this.canvas.height / 2; // Screen position
                const roadTopY = roadCenterY - this.totalRoadWidth/2;
                const roadBottomY = roadCenterY + this.totalRoadWidth/2;
                
                // Road surface (straight)
                this.ctx.fillStyle = '#2a2a2a';
                this.ctx.fillRect(0, roadTopY, this.canvas.width, this.totalRoadWidth);
                
                // Draw animated lane markings that move to the left
                for (let offset = -40; offset <= this.canvas.width + 40; offset += 40) {
                    const xPos = offset - this.roadOffset;
                    
                    // WHITE SOLID LINES - Road edges
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([]);
                    
                    // Top road edge
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, roadTopY);
                    this.ctx.lineTo(xPos + 40, roadTopY);
                    this.ctx.stroke();
                    
                    // Bottom road edge
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, roadBottomY);
                    this.ctx.lineTo(xPos + 40, roadBottomY);
                    this.ctx.stroke();
                }
                
                // YELLOW DASHED CENTER LINE (divides left and right lanes)
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([15, 15]);
                
                for (let offset = -40; offset <= this.canvas.width + 40; offset += 40) {
                    const xPos = offset - this.roadOffset;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, roadCenterY);
                    this.ctx.lineTo(xPos + 40, roadCenterY);
                    this.ctx.stroke();
                }
                
                // LANE CENTER REFERENCES (green dashed)
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 10]);
                
                // Left lane center (relative to vehicle position)
                for (let offset = -40; offset <= this.canvas.width + 40; offset += 40) {
                    const xPos = offset - this.roadOffset;
                    const leftCenterY = roadCenterY - this.laneWidth/2;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, leftCenterY);
                    this.ctx.lineTo(xPos + 40, leftCenterY);
                    this.ctx.stroke();
                }
                
                // Right lane center (relative to vehicle position)
                for (let offset = -40; offset <= this.canvas.width + 40; offset += 40) {
                    const xPos = offset - this.roadOffset;
                    const rightCenterY = roadCenterY + this.laneWidth/2;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, rightCenterY);
                    this.ctx.lineTo(xPos + 40, rightCenterY);
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
                
                // Highlight current target lane (relative to vehicle position)
                const worldTargetY = this.getCurrentTargetY(this.vehicle.x);
                const screenTargetY = worldTargetY - this.vehicle.y + this.canvas.height / 2;
                this.ctx.strokeStyle = this.isChangingLanes ? 'rgba(255, 152, 0, 0.8)' : 'rgba(0, 255, 136, 0.8)';
                this.ctx.lineWidth = 4;
                this.ctx.setLineDash([10, 5]);
                
                for (let offset = -40; offset <= this.canvas.width + 40; offset += 40) {
                    const xPos = offset - this.roadOffset;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, screenTargetY);
                    this.ctx.lineTo(xPos + 40, screenTargetY);
                    this.ctx.stroke();
                }
                this.ctx.setLineDash([]);
            }

            drawPredictedPath() {
                if (this.predictedPath.length < 2) return;
                
                // Draw prediction line
                this.ctx.lineWidth = 4;
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.beginPath();
                
                for (let i = 0; i < this.predictedPath.length; i++) {
                    const state = this.predictedPath[i];
                    const screenX = this.canvas.width/2 + (state.x - this.vehicle.x);
                    const screenY = this.canvas.height/2 + (state.y - this.vehicle.y);
                    
                    if (i === 0) {
                        this.ctx.moveTo(screenX, screenY);
                    } else {
                        this.ctx.lineTo(screenX, screenY);
                    }
                }
                this.ctx.stroke();
                
                // Draw prediction waypoints
                for (let i = 1; i < this.predictedPath.length; i += 3) {
                    const state = this.predictedPath[i];
                    const screenX = this.canvas.width/2 + (state.x - this.vehicle.x);
                    const screenY = this.canvas.height/2 + (state.y - this.vehicle.y);
                    
                    const alpha = Math.max(0.3, 1.0 - (i / this.predictedPath.length));
                    this.ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Prediction horizon info
                this.ctx.fillStyle = 'rgba(0, 255, 136, 0.8)';
                this.ctx.font = 'bold 12px monospace';
                this.ctx.fillText(`MPC Horizon: ${this.horizon} steps (${(this.horizon * this.dt).toFixed(1)}s)`, 
                                this.canvas.width - 250, 30);
            }

            drawTrajectory() {
                if (this.trajectory.length < 2) return;
                
                this.ctx.strokeStyle = '#4CAF50';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                for (let i = 0; i < this.trajectory.length; i++) {
                    const point = this.trajectory[i];
                    const screenX = this.canvas.width/2 + (point.x - this.vehicle.x);
                    const screenY = this.canvas.height/2 + (point.y - this.vehicle.y);
                    
                    if (i === 0) {
                        this.ctx.moveTo(screenX, screenY);
                    } else {
                        this.ctx.lineTo(screenX, screenY);
                    }
                }
                this.ctx.stroke();
            }

            drawVehicle() {
                const screenX = this.canvas.width / 2;
                const screenY = this.canvas.height / 2;
                
                this.ctx.save();
                this.ctx.translate(screenX, screenY);
                this.ctx.rotate(this.vehicle.theta);
                
                // Vehicle body
                this.ctx.fillStyle = '#2196F3';
                this.ctx.fillRect(-15, -8, 30, 16);
                
                // Vehicle direction indicator
                this.ctx.fillStyle = '#FF5722';
                this.ctx.fillRect(10, -4, 8, 8);
                
                // Wheels showing steering
                this.ctx.save();
                this.ctx.translate(10, -6);
                this.ctx.rotate(this.currentSteering);
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(-2, -3, 4, 6);
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.translate(10, 6);
                this.ctx.rotate(this.currentSteering);
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(-2, -3, 4, 6);
                this.ctx.restore();
                
                this.ctx.restore();
            }

            drawPerformanceOverlay() {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = '14px monospace';
                this.ctx.fillText(`MPC Horizon: ${this.horizon} steps`, 20, 30);
                this.ctx.fillText(`Solve Time: ${this.metrics.solveTime.toFixed(1)} ms`, 20, 50);
                this.ctx.fillText(`Real-time Factor: ${(100 / Math.max(this.metrics.solveTime, 16)).toFixed(1)}x`, 20, 70);
                
                // Performance indicator
                const rtFactor = 100 / Math.max(this.metrics.solveTime, 16);
                const color = rtFactor > 5 ? '#4CAF50' : rtFactor > 2 ? '#FF9800' : '#f44336';
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(280, 65, 5, 0, 2 * Math.PI);
                this.ctx.fill();
            }

            drawMPCStatus() {
                // MPC algorithm status box
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(this.canvas.width - 340, this.canvas.height - 200, 320, 180);
                
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.canvas.width - 340, this.canvas.height - 200, 320, 180);
                
                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = 'bold 11px monospace';
                this.ctx.fillText('MPC LANE CHANGING', this.canvas.width - 335, this.canvas.height - 180);
                
                this.ctx.font = '10px monospace';
                this.ctx.fillStyle = 'white';
                const targetY = this.getCurrentTargetY(this.vehicle.x);
                const lateralError = this.vehicle.y - targetY;
                
                let line = this.canvas.height - 162;
                this.ctx.fillText(`Current Lane: ${this.currentLane.toUpperCase()}`, this.canvas.width - 335, line);
                line += 12;
                
                if (this.isChangingLanes) {
                    this.ctx.fillStyle = '#FF9800';
                    this.ctx.fillText(`Lane Change: ${this.currentLane.toUpperCase()} ‚Üí ${this.targetLane.toUpperCase()}`, this.canvas.width - 335, line);
                    line += 12;
                    this.ctx.fillText(`Progress: ${Math.round(this.laneChangeProgress * 100)}%`, this.canvas.width - 335, line);
                    line += 12;
                    this.ctx.fillText(`Duration: ${this.laneChangeDuration.toFixed(1)}s, Max Angle: ${this.maxLaneChangeAngle}¬∞`, this.canvas.width - 335, line);
                    line += 12;
                    
                    // Show heading control during lane changes
                    const currentHeadingDeg = (this.vehicle.theta * 180 / Math.PI).toFixed(1);
                    this.ctx.fillText(`Vehicle Heading: ${currentHeadingDeg}¬∞ (Controlled)`, this.canvas.width - 335, line);
                    line += 12;
                    this.ctx.fillStyle = 'white';
                } else {
                    this.ctx.fillText(`Settings: ${this.laneChangeDuration.toFixed(1)}s, Max ${this.maxLaneChangeAngle}¬∞`, this.canvas.width - 335, line);
                    line += 12;
                    this.ctx.fillText(`Vehicle Heading: ${(this.vehicle.theta * 180 / Math.PI).toFixed(1)}¬∞`, this.canvas.width - 335, line);
                    line += 15;
                }
                
                this.ctx.fillText(`Lateral Error: ${lateralError.toFixed(2)} m`, this.canvas.width - 335, line);
                line += 12;
                this.ctx.fillText(`Steering: ${(this.currentSteering * 180/Math.PI).toFixed(1)}¬∞`, this.canvas.width - 335, line);
                line += 12;
                this.ctx.fillText(`Solve: ${this.metrics.solveTime.toFixed(1)} ms`, this.canvas.width - 335, line);
                
                // Status indicator based on heading control
                const headingMagnitude = Math.abs(this.vehicle.theta * 180 / Math.PI);
                // During lane changes, allow up to 1.5x the maximum lane change angle
                // During normal driving, keep heading within 2 degrees
                const maxExpectedHeading = this.isChangingLanes ? this.maxLaneChangeAngle * 1.5 : 2.0;
                
                let status, statusColor;
                if (headingMagnitude < maxExpectedHeading / 2) {
                    status = 'STRAIGHT';
                    statusColor = '#4CAF50'; // Green
                } else if (headingMagnitude < maxExpectedHeading) {
                    status = 'CONTROLLED';
                    statusColor = '#FF9800'; // Orange
                } else {
                    status = 'HIGH-ANGLE';
                    statusColor = '#f44336'; // Red
                }
                
                this.ctx.fillStyle = statusColor;
                this.ctx.fillText(`Heading Status: ${status}`, this.canvas.width - 335, this.canvas.height - 30);
            }

            drawLegend() {
                // Enhanced legend
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(20, this.canvas.height - 180, 300, 160);
                
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(20, this.canvas.height - 180, 300, 160);
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 12px monospace';
                this.ctx.fillText('STRAIGHT ROAD LANE CHANGE LEGEND', 25, this.canvas.height - 160);
                
                this.ctx.font = '10px monospace';
                let y = this.canvas.height - 145;
                
                // Vehicle
                this.ctx.fillStyle = '#2196F3';
                this.ctx.fillRect(25, y - 5, 15, 8);
                this.ctx.fillStyle = 'white';
                this.ctx.fillText('Vehicle', 45, y);
                y += 15;
                
                // Predicted path
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(25, y);
                this.ctx.lineTo(40, y);
                this.ctx.stroke();
                this.ctx.fillStyle = 'white';
                this.ctx.fillText('MPC Predicted Path', 45, y + 3);
                y += 15;
                
                // Target lane (during lane change)
                this.ctx.strokeStyle = '#FF9800';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([10, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(25, y);
                this.ctx.lineTo(40, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.fillStyle = 'white';
                this.ctx.fillText('Target Path (during lane change)', 45, y + 3);
                y += 15;
                
                // Yellow center line
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([8, 8]);
                this.ctx.beginPath();
                this.ctx.moveTo(25, y);
                this.ctx.lineTo(40, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.fillStyle = 'white';
                this.ctx.fillText('Yellow Center Line', 45, y + 3);
                y += 15;
                
                // Lane centers
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 10]);
                this.ctx.beginPath();
                this.ctx.moveTo(25, y);
                this.ctx.lineTo(40, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                this.ctx.fillText('Lane Centers', 45, y + 3);
                y += 15;
                
                // Instructions
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.fillText('REALISTIC lane changes - adjust max angle!', 25, y);
                y += 12;
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.fillText('Adaptive heading control keeps car straighter', 25, y);
            }

            togglePauseResume() {
                this.running = !this.running;
                const btn = document.getElementById('pauseResumeBtn');
                btn.textContent = this.running ? 'Pause' : 'Resume';
            }

            reset() {
                this.vehicle = {
                    x: 50,
                    y: this.canvas.height / 2 + 20, // Start in right lane
                    theta: 0,
                    v: this.targetSpeed
                };
                
                // Reset lane state
                this.currentLane = 'right';
                this.targetLane = 'right';
                this.isChangingLanes = false;
                this.laneChangeProgress = 0;
                
                this.trajectory = [];
                this.predictedPath = [];
                this.currentSteering = 0;
                this.running = true;
                
                document.getElementById('pauseResumeBtn').textContent = '‚è∏Ô∏è Pause';
                this.updateLaneChangeUI();
            }

            animationLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animationLoop());
            }
        }

        // Initialize the MPC visualizer with lane changing capability
        const mpcViz = new ProfessionalMPCVisualizer();
    </script>
</body>
</html>